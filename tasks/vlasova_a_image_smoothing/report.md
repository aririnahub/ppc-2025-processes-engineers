# Сглаживание изображений

- Student: Власова Арина Сергеевна, group 3823Б1ПР2
- Technology: SEQ | MPI 
- Variant: 22

## 1. Введение
Медианная фильтрация — распространенный метод обработки изображений, используемый для удаления шума при сохранении границ объектов. В отличие от линейных фильтров, медианный фильтр эффективно устраняет импульсный шум (например, "соль-перец"). Цель работы — реализовать эффективный медианный фильтр с поддержкой параллельной обработки для больших изображений.

## 2. Постановка задачи
Задача: Применить медианный фильтр к полутоновому изображению.

### Входные данные:
Изображение в формате ImageData (ширина, высота, вектор пикселей uint8_t)и размер окна фильтрации (3, 5 или 7)

### Выходные данные:
Отфильтрованное изображение того же размера

### Алгоритм:
Для каждого пикселя выходного изображения:
1) Собрать значения всех пикселей в окрестности заданного размера
2) Отсортировать собранные значения
3) Выбрать медианное значение (центральный элемент отсортированного массива)

В реализации алгоритма есть некоторые особенности: 
- Окно всегда квадратное и нечетного размера
- На границах изображения учитываются только существующие пиксели

## 3. Последовательный алгоритм
Алгоритм реализован в классе VlasovaAImageSmoothingSEQ и следует паттерну Template Method, предоставляя единый интерфейс через методы жизненного цикла:

### 3.1 Фазы выполнения
1) Валидация (ValidationImpl()): Проверка корректности входных данных
- Проверка положительных размеров изображения
- Проверка соответствия размера вектора данных заявленным размерам
2) Предобработка (PreProcessingImpl()): Инициализация структур данных
- Сохранение размеров изображения
- Копирование входных данных
- Выделение памяти для выходного изображения
3) Выполнение (RunImpl()): Основной алгоритм фильтрации
- Для каждого пикселя строится окрестность размера window_size_ × window_size_
- Используется лямбда-функция calculate_pixel_median для вычисления медианы
- Алгоритм std::nth_element находит медиану за O(n)
- Граничные пиксели обрабатываются с учетом доступных соседей
4) Постобработка (PostProcessingImpl()): Формирование результата
- Установка размеров выходного изображения
- Проверка корректности выходных данных

### 3.2 Ключевой алгоритм вычисления медианы
Основная вычислительная логика сосредоточена в лямбда-функции, которая выполняется для каждого пикселя изображения. Алгоритм состоит из нескольких этапов:

Этап 1: Сбор значений окрестности
Для текущего пикселя с координатами (col_idx, row_idx) собираются значения всех пикселей в квадратной окрестности размером window_size_ x window_size_. Выполняется проверка границ изображения: если соседний пиксель выходит за пределы изображения, он не включается в окрестность. Все допустимые значения сохраняются во временном векторе.
Этап 2: Эффективное нахождение медианы
Вместо полной сортировки всего вектора окрестности используется алгоритм std::nth_element. Этот алгоритм частично упорядочивает последовательность так, что элемент на заданной позиции (в данном случае — центральный элемент) занимает свое окончательное положение в отсортированной последовательности. Все элементы слева от него меньше или равны, а справа — больше или равны.
Этап 3: Обработка особых случаев
Если окрестность пикселя оказывается пустой (что возможно только для несуществующих пикселей), функция возвращает исходное значение пикселя. Для граничных пикселей окрестность содержит только те пиксели, которые фактически существуют в изображении, что обеспечивает корректную обработку краев.
Этап 4: Формирование результата
Вычисленное медианное значение присваивается соответствующему пикселю в выходном изображении. Процесс повторяется для всех пикселей изображения в порядке сканирования построчно слева направо и сверху вниз.

### 3.3 Оптимизации
- Для вектора, хранящего значения окрестности, заранее резервируется память под максимально возможное количество элементов (window_size_ × window_size_), что исключает многократные перераспределения памяти.
- Часто используемые значения (радиус окна, размеры изображения) сохраняются в локальные переменные для быстрого доступа.
- Индексы в линейном массиве вычисляются по формуле row × width + column, что позволяет эффективно обращаться к данным.

## 4. Схема параллелизации (MPI)
### Распределение данных:

Изображение делится по строкам между процессами с использованием блочно-циклического распределения для балансировки нагрузки:
- Базовое количество строк на процесс: base_rows = height / size
- Дополнительные строки для первых extra_rows процессов
- Каждый процесс получает свой диапазон строк: от start_row до end_row (невключительно)

Для корректной обработки граничных пикселей используется перекрытие (overlap):
- Размер перекрытия: radius = window_size / 2
- Каждый процесс получает дополнительные строки сверху и снизу
- Перекрытие исключает необходимость дополнительных коммуникаций во время фильтрации

Процесс обработки состоит из пяти основных этапов:

1. Распределение данных (Scatterv)
Функция PrepareScatterData() вычисляет:
- количество элементов для каждого процесса - sendcounts[]
- смещения в глобальном массиве - displs[]
Каждый процесс получает overlap_height × width элементов.

2. Локальная обработка
Каждый процесс независимо выполняет медианную фильтрацию для своих основных строк (без учета overlap):

Используется функция ComputePixelMedian() — общий алгоритм с SEQ реализацией
Обрабатываются только строки от start_row до end_row (невключительно)
Overlap области используются только как справочные данные

3. Сбор результатов (Gatherv)
Функция PrepareGatherData() вычисляет параметры для сбора только полезных данных.

4. Распространение результата (Broadcast)
Ранг 0 рассылает размер результата MPI_Bcast(&data_size, ...)
Все процессы выделяют память под результат
Ранг 0 рассылает само изображение MPI_Bcast(GetOutput().data.data(), ...)

5. Синхронизация
Все процессы имеют идентичные выходные данные независимо от их ранга.

## 5. Детали реализации
ops_mpi.cpp - MPI реализация
ops_seq.cpp - SEQ реализация
common.hpp - общие типы данных
Тесты в папках tests/functional/ и tests/performance/ 

### Ключевые классы:
VlasovaAImageSmoothingSEQ — последовательная реализация
VlasovaAImageSmoothingMPI — параллельная MPI реализация
ImageData — структура для хранения изображения

### Особенности реализации:
1) Обработка граничных пикселей:
В SEQ: проверка индексов в границах изображения
В MPI: использование overlap областей для граничных строк
2) Эффективное использование памяти:
Предварительное резервирование reserve() для векторов
Локальные копии часто используемых параметров
3) Валидация данных:
Проверка положительности размеров
Проверка соответствия размера вектора
В MPI: broadcast статуса валидации от ранга 0
4) Алгоритмические оптимизации:
Использование std::nth_element вместо std::sort (O(n) vs O(n log n))
Минимизация операций вычисления индексов

## 6. Экспериментальная установка
### Аппаратное обеспечение:
- Процессор: Intel(R) Core(TM) Ultra 9 285H (2.90 GHz)
- Оперативная память: 32 GB
- ОС: Windows 11

### Инструментарий:
- Компилятор: clang version 21.1.6
- Версия MPI: MS-MPI v10.1.3
- Тип сборки: Release

### Тестовые данные:
- Функциональные тесты: 64x64 пикселей, градиент + шум
- Тесты производительности: 512x512 пикселей, случайные значения ((idx × 37) % 256)
- Размеры окна: 3, 5, 7

## 7. Результаты и обсуждение

### 7.1 Корректность
Корректность проверена:
- Сравнением результатов SEQ и MPI реализаций
- Проверкой инвариантов (размеры сохраняются)
- Функциональными тестами с известными ожидаемыми результатами

### 7.2 Performance
Present time, speedup and efficiency. Example table:

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| seq         | 1     | 0,495   | 1.00    | N/A        |
| mpi         | 2     | 0.362   | 1.37    | 68.5%      |
| mpi         | 4     | 0.158   | 3.13    | 78.3%      |
| mpi         | 8     | 0.093   | 5.32    | 66.5%      |

### Анализ результатов:
Лучшая эффективность достигается при 4 процессах (78.3%)
Рост ускорения практически линейный до 4 процессов
Снижение эффективности на 8 процессах связано с:
- Увеличением накладных расходов коммуникаций
- Неидеальным балансом нагрузки при малом количестве строк на процесс
- Накладными расходами на создание overlap областей

## 8. Выводы
### 8.1 Основные достижения
Реализован корректный медианный фильтр для полутоновых изображений
Обеспечена идентичность результатов SEQ и MPI реализаций
Достигнуто ускорение до 5.32 на 8 процессах
Создана модульная архитектура с повторным использованием кода

### 8.2 Ограничения и улучшения
Текущие ограничения:
Фиксированные нечетные размеры окна
Квадратная форма окна фильтрации
Ограниченная масштабируемость для малых изображений

Возможные улучшения:
- Поддержка произвольных размеров окна
- Адаптивное распределение при малом количестве строк

## 9. Ссылки
1. Курс лекций по параллельному программированию Сысоева Александра Владимировича. 
2. Документация по курсу: https://learning-process.github.io/parallel_programming_course/ru

## Приложение
```cpp
bool VlasovaAImageSmoothingMPI::RunImpl() {
  int rank = 0;
  int size = 1;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &size);

  const int radius = window_size_ / 2;
  const int base_rows = height_ / size;
  const int extra_rows = height_ % size;

  const int start_row = (rank * base_rows) + std::min(rank, extra_rows);
  const int end_row = start_row + base_rows + (rank < extra_rows ? 1 : 0);
  const int local_height = end_row - start_row;

  if (local_height <= 0) {
    GetOutput().width = width_;
    GetOutput().height = height_;
    GetOutput().data.clear();
    return true;
  }

  const int overlap_start = std::max(0, start_row - radius);
  const int overlap_end = std::min(height_, end_row + radius);
  const int overlap_height = overlap_end - overlap_start;

  std::vector<std::uint8_t> full_image;
  if (rank == 0) {
    full_image = GetInput().data;
  }

  std::vector<int> sendcounts(static_cast<std::size_t>(size));
  std::vector<int> displs(static_cast<std::size_t>(size));

  if (rank == 0) {
    PrepareScatterData(size, width_, height_, radius, sendcounts, displs);
  }

  std::vector<std::uint8_t> local_image(static_cast<std::size_t>(overlap_height) * width_);
  MPI_Scatterv((rank == 0 ? full_image.data() : nullptr), sendcounts.data(), displs.data(), MPI_UNSIGNED_CHAR,
               local_image.data(), overlap_height * width_, MPI_UNSIGNED_CHAR, 0, MPI_COMM_WORLD);

  std::vector<std::uint8_t> local_result(static_cast<std::size_t>(local_height) * width_);
  for (int local_row = 0; local_row < local_height; ++local_row) {
    const int global_row = start_row + local_row;

    for (int col_idx = 0; col_idx < width_; ++col_idx) {
      const std::size_t index = (static_cast<std::size_t>(local_row) * width_) + col_idx;
      local_result[index] =
          ComputePixelMedian(col_idx, global_row, overlap_start, local_image, width_, height_, window_size_);
    }
  }

  std::vector<std::uint8_t> result_image;
  if (rank == 0) {
    result_image.resize(static_cast<std::size_t>(width_) * height_);
  }

  if (rank == 0) {
    PrepareGatherData(size, width_, height_, sendcounts, displs);
  }

  MPI_Gatherv(local_result.data(), local_height * width_, MPI_UNSIGNED_CHAR,
              (rank == 0 ? result_image.data() : nullptr), sendcounts.data(), displs.data(), MPI_UNSIGNED_CHAR, 0,
              MPI_COMM_WORLD);

  if (rank == 0) {
    GetOutput().width = width_;
    GetOutput().height = height_;
    GetOutput().data = result_image;
  } else {
    GetOutput().width = width_;
    GetOutput().height = height_;
  }

  int data_size = static_cast<int>(GetOutput().data.size());
  MPI_Bcast(&data_size, 1, MPI_INT, 0, MPI_COMM_WORLD);

  if (rank != 0) {
    GetOutput().data.resize(static_cast<std::size_t>(data_size));
  }

  MPI_Bcast(GetOutput().data.data(), data_size, MPI_UNSIGNED_CHAR, 0, MPI_COMM_WORLD);
  return true;
}
```